#!/usr/bin/env python3

import argparse
import os
import re
import sys

from collections import namedtuple
from difflib import SequenceMatcher
from enum import Enum


class MatchType(Enum):
    SUBSTRING = 1
    EXACT_STRING = 2
    REGEX = 3


class CheckType(Enum):
    CHECK = 1
    CHECK_NOT = 2
    CHECK_EMPTY = 3


Check = namedtuple("Check", "check_type match_type expression source_line check_line_idx start_index")


def similar(a, b):
    return SequenceMatcher(None, a, b).ratio()


def dump_check(check):
    print("check dump")
    print("\tcheck_type: {}".format(check.check_type))
    print("\tmatch_type: {}".format(check.match_type))
    print("\texpression: {}".format(check.expression))
    print("\tsource_line: {}".format(check.source_line))
    print("\tcheck_line_idx: {}".format(check.check_line_idx))
    print("\tstart_index: {}".format(check.start_index))


# FileCheck always prints its first argument.
print(sys.argv[0])

if len(sys.argv) == 1:
    print("<check-file> not specified")
    exit(2)

check_file = sys.argv[1]
if not os.path.isfile(check_file):
    err = "Could not open check file '{}': No such file or directory".format(check_file)
    print(err)
    sys.stdout.flush()
    exit(2)

if os.path.getsize(check_file) == 0:
    sys.stdout.flush()
    print("error: no check strings found with prefix 'CHECK:'", file=sys.stderr)
    exit(2)

parser = argparse.ArgumentParser()

parser.add_argument('check_file_arg', type=str, help='TODO')
parser.add_argument('--strict-whitespace', action='store_true', help='TODO')

args = parser.parse_args()

checks = []
with open(check_file) as f:
    for line_idx, line in enumerate(f):
        line = line.rstrip()

        if not args.strict_whitespace:
            line = re.sub("\\s+", ' ', line).strip()

        check_match = re.search('; CHECK: (.*)', line)
        if check_match:
            check_expression = check_match.group(1)

            match_type = MatchType.SUBSTRING

            regex_line = re.sub(r"\{\{(.*?)\}\}", r"\1", check_expression)

            if check_expression != regex_line:
                match_type = MatchType.REGEX
                check_expression = regex_line

            check = Check(check_type=CheckType.CHECK,
                          match_type=match_type,
                          expression=check_expression,
                          source_line=line,
                          check_line_idx=line_idx,
                          start_index=check_match.start(1))

            checks.append(check)
            continue

        check_match = re.search('; CHECK-NOT: (.*)', line)
        if check_match:
            match_type = MatchType.SUBSTRING

            check_expression = check_match.group(1)

            regex_line = re.sub(r"\{\{(.*?)\}\}", r"\1", check_expression)

            if check_expression != regex_line:
                match_type = MatchType.REGEX
                check_expression = regex_line

            check = Check(check_type=CheckType.CHECK_NOT,
                          match_type=match_type,
                          expression=check_expression,
                          source_line=line,
                          check_line_idx=line_idx,
                          start_index=check_match.start(1))

            checks.append(check)
            continue

        check_match = re.search('; CHECK-EMPTY:', line)
        if check_match:
            check = Check(check_type=CheckType.CHECK_EMPTY,
                          match_type=MatchType.SUBSTRING,
                          expression=None,
                          source_line=line,
                          check_line_idx=line_idx,
                          start_index=-1)

            if len(checks) == 0:
                print("{}:{}:{}: error: found 'CHECK-EMPTY' without previous 'CHECK: line".format(check_file, 1, 3))
                print(line)
                print("  ^")
                exit(2)

            checks.append(check)
            continue

check_iterator = iter(checks)

current_check = None
try:
    current_check = next(check_iterator)
except StopIteration:
    print("error: no check strings found with prefix 'CHECK:'", file=sys.stderr)
    sys.stdout.flush()
    exit(2)

line_counter = 0

input_lines = []

current_scan_base = 0

for line_idx, line in enumerate(sys.stdin):
    input_lines.append(line.rstrip())

    line_counter = line_counter + 1

    if current_check.check_type == CheckType.CHECK_EMPTY:
        if line != '\n':
            assert 0, "Not implemented"

    elif current_check.check_type == CheckType.CHECK:
        if current_check.match_type == MatchType.SUBSTRING:
            if not args.strict_whitespace:
                line = re.sub("\\s+", ' ', line).strip()

            if current_check.expression not in line:
                continue

        elif current_check.match_type == MatchType.REGEX:
            if not re.search(current_check.expression, line):
                continue

    elif current_check.check_type == CheckType.CHECK_NOT:
        if current_check.match_type == MatchType.SUBSTRING:
            if not args.strict_whitespace:
                line = re.sub("\\s+", ' ', line).strip()

            if current_check.expression in line:
                break

        elif current_check.match_type == MatchType.REGEX:
            if re.search(current_check.expression, line):
                break

    try:
        current_check = next(check_iterator)
        current_scan_base = line_idx + 1
    except StopIteration:
        exit(0)

if line_counter == 0:
    print("CHECK: FileCheck error: '-' is empty.")
    print("FileCheck command line: {}".format(check_file))
    exit(2)

if current_check.check_type == CheckType.CHECK_EMPTY:
    exit(0)

if current_check.check_type == CheckType.CHECK:
    if current_check.match_type == MatchType.SUBSTRING:
        last_read_line = input_lines[current_scan_base]

        candidate_line = None
        current_best_ratio = 0
        for read_line in input_lines[current_scan_base:]:
            similar_ratio = similar(last_read_line, current_check.expression)
            if current_best_ratio < similar_ratio:
                candidate_line = read_line
                current_best_ratio = similar_ratio
        assert candidate_line

        print("{}:{}:{}: error: CHECK: expected string not found in input"
              .format(check_file,
                      current_check.check_line_idx + 1,
                      current_check.start_index + 1))

        print(current_check.source_line.rstrip())
        print("^".rjust(current_check.start_index + 1))
        print("<stdin>:?:?: note: scanning from here")
        print(last_read_line)
        print("^")
        print("<stdin>:?:?: note: possible intended match here")
        print(candidate_line)
        print("^".rjust(len(candidate_line) // 2, ' '))
        exit(1)

    if current_check.match_type == MatchType.REGEX:
        print("{}:{}:{}: error: CHECK: expected string not found in input"
              .format(check_file,
                      current_check.check_line_idx + 1,
                      current_check.start_index + 1))

        print(current_check.source_line.rstrip())
        print("          ^")
        print("<stdin>:?:?: note: scanning from here")
        print(line)
        print("^")
        exit(1)

if current_check.check_type == CheckType.CHECK_NOT:
    if (current_check.match_type == MatchType.SUBSTRING or
            current_check.match_type == MatchType.REGEX):
        last_read_line = input_lines[-1]
        if not args.strict_whitespace:
            last_read_line = re.sub("\\s+", ' ', last_read_line).strip()

        print("{}:{}:{}: error: CHECK-NOT: excluded string found in input"
              .format(check_file,
                      current_check.check_line_idx + 1,
                      current_check.start_index + 1))

        print(current_check.source_line.rstrip())
        print("^".rjust(current_check.start_index + 1))
        print("<stdin>:?:?: note: found here")
        print(last_read_line)
        print("^".ljust(len(last_read_line), '~'))
        exit(1)

    assert 0, "Not implemented"
