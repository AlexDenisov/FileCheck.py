#!/usr/bin/env python3

import os
import re
import sys

from collections import namedtuple
from enum import Enum


class MatchType(Enum):
    SUBSTRING = 1
    EXACT_STRING = 2
    REGEX = 3


class CheckType(Enum):
    CHECK = 1
    CHECK_NOT = 2
    CHECK_EMPTY = 3


Check = namedtuple("Check", "check_type match_type expression source_line start_index")


def dump_check(check):
    print("check dump")
    print("\tcheck_type: {}".format(check.check_type))
    print("\tmatch_type: {}".format(check.match_type))
    print("\texpression: {}".format(check.expression))
    print("\tsource_line: {}".format(check.source_line))
    print("\tstart_index: {}".format(check.start_index))


# FileCheck always prints its first argument.
print(sys.argv[0])

if len(sys.argv) == 1:
    print("<check-file> not specified")
    exit(2)

check_file = sys.argv[1]
if not os.path.isfile(check_file):
    err = "Could not open check file '{}': No such file or directory".format(check_file)
    print(err)
    sys.stdout.flush()
    exit(2)

if os.path.getsize(check_file) == 0:
    sys.stdout.flush()
    print("error: no check strings found with prefix 'CHECK:'", file=sys.stderr)
    exit(2)

checks = []
with open(check_file) as f:
    for line in f:
        line = line.rstrip()
        check_match = re.search('; CHECK: (.*)', line)
        if check_match:
            check_expression = check_match.group(1)

            match_type = MatchType.SUBSTRING

            regex_line = re.sub(r"\{\{(.*?)\}\}", r"\1", check_expression)

            if check_expression != regex_line:
                match_type = MatchType.REGEX
                check_expression = regex_line
            else:
                check_expression = re.sub("\\s+", ' ', check_expression).strip()

            check = Check(check_type=CheckType.CHECK,
                          match_type=match_type,
                          expression=check_expression,
                          source_line=line,
                          start_index=check_match.start(1))

            checks.append(check)
            continue

        check_match = re.search('; CHECK-NOT: (.*)', line)
        if check_match:
            match_type = MatchType.SUBSTRING

            check_expression = check_match.group(1)

            regex_line = re.sub(r"\{\{(.*?)\}\}", r"\1", check_expression)

            if check_expression != regex_line:
                match_type = MatchType.REGEX
                check_expression = regex_line
            else:
                check_expression = re.sub("\\s+", ' ', check_expression).strip()

            check = Check(check_type=CheckType.CHECK_NOT,
                          match_type=match_type,
                          expression=check_expression,
                          source_line=line,
                          start_index=check_match.start(1))

            checks.append(check)
            continue

        check_match = re.search('; CHECK-EMPTY:', line)
        if check_match:
            check = Check(check_type=CheckType.CHECK_EMPTY,
                          match_type=MatchType.SUBSTRING,
                          expression=None,
                          source_line=line,
                          start_index=-1)

            if len(checks) == 0:
                print("{}:{}:{}: error: found 'CHECK-EMPTY' without previous 'CHECK: line".format(check_file, 1, 3))
                print(line)
                print("  ^")
                exit(2)

            checks.append(check)
            continue

check_iterator = iter(checks)

line_counter = 0

current_check = None
try:
    current_check = next(check_iterator)
except StopIteration:
    print("error: no check strings found with prefix 'CHECK:'", file=sys.stderr)
    sys.stdout.flush()
    exit(2)

current_line = None
current_line_number = 0
for line in sys.stdin:
    current_line = line
    current_line_number += 1

    line_counter = 1

    if current_check.check_type == CheckType.CHECK_EMPTY:
        if line != '\n':
            assert 0, "Not implemented"

    if current_check.check_type == CheckType.CHECK:
        if current_check.match_type == MatchType.SUBSTRING:
            line = re.sub("\\s+", ' ', line).strip()

            if current_check.expression not in line:
                continue

        elif current_check.match_type == MatchType.REGEX:
            if not re.search(current_check.expression, line):
                continue

    if current_check.check_type == CheckType.CHECK_NOT:
        if current_check.match_type == MatchType.SUBSTRING:
            line = re.sub("\\s+", ' ', line).strip()

            if current_check.expression in line:
                break

        elif current_check.match_type == MatchType.REGEX:
            if re.search(current_check.expression, line):
                break

    try:
        current_check = next(check_iterator)
    except StopIteration:
        exit(0)

if line_counter == 0:
    print("CHECK: FileCheck error: '-' is empty.")
    print("FileCheck command line: {}".format(check_file))
    exit(2)

if current_check.check_type == CheckType.CHECK_EMPTY:
    exit(0)

if current_check.check_type == CheckType.CHECK:
    if current_check.match_type == MatchType.SUBSTRING:
        print("{}:{}:{}: error: CHECK: expected string not found in input"
              .format(check_file, line_counter, current_check.start_index + 1))

        print(current_check.source_line.rstrip())
        print("^".rjust(current_check.start_index + 1))
        print("<stdin>:?:?: note: scanning from here")
        print(current_line)
        print("^")
        print("<stdin>:?:?: note: possible intended match here")
        print("TODO")
        print("  ^")
        exit(2)

    if current_check.match_type == MatchType.REGEX:
        print("{}:{}:{}: error: CHECK: expected string not found in input"
              .format(check_file, line_counter, current_check.start_index + 1))

        print(current_check.source_line.rstrip())
        print("          ^")
        print("<stdin>:?:?: note: scanning from here")
        print(line)
        print("^")
        exit(1)

if current_check.check_type == CheckType.CHECK_NOT:
    if (current_check.match_type == MatchType.SUBSTRING or
            current_check.match_type == MatchType.REGEX):
        print("{}:{}:{}: error: CHECK-NOT: excluded string found in input"
              .format(check_file, line_counter, current_check.start_index + 1))

        print(current_check.source_line.rstrip())
        print("^".rjust(current_check.start_index + 1))
        print("<stdin>:?:?: note: found here")
        print(current_line)
        print("^".ljust(len(current_line), '~'))
        exit(1)

    assert 0, "Not implemented"
